<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Push Up Odyssey</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Lien vers le manifest -->
  <link rel="manifest" href="manifest.json">

  <!-- Biblioth√®ques p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>
  
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }
    button {
      position: absolute;
      z-index: 10;
      font-size: 20px;
      padding: 10px 20px;
    }
    #startButton { top: 20px; left: 20px; }
    #stopButton { top: 20px; right: 20px; }
    #chrono {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      color: white;
      z-index: 10;
    }
    #level {
      position: absolute;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      font-weight: bold;
      background-color: white;
      padding: 2px 6px;
      color: black;
      z-index: 10;
    }
    #restartButton {
      position: absolute;
      z-index: 20;
      font-size: 24px;
      padding: 10px 20px;
      display: none;
      background-color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
    }
    /* --- AJOUTE √áA tout en bas de ton <style> existant --- */
#startButton,
#stopButton,
#chrono,
#level,
#restartButton{
  display:none;      /* cach√© d√®s la construction du DOM   */
}
  </style>
</head>

<body>
  <!-- √âl√©ments HTML fixes -->
  <div id="chrono">Temps: 0.0 sec</div>
  <div id="level">Niveau: <span style="color:white;">1</span></div>
  <div id="odysseyChrono">Odyss√©e: 0.0 sec</div>
  <button id="startButton">üí™üòéGo !</button>
  <button id="stopButton">√âchecü•µ</button>
  <button id="restartButton">Recommencer üîÑ</button>

  <script>
    /********************************************
     ** 1) Variables pour IMAGES et PRELOAD    **
     ********************************************/
   // ‚Äî record persistant (en ms) et dur√©e de la session en cours ‚Äî
    let bestTime = 0;
    let sessionTime = 0;
    let validateBtn;
    
    let pushupImg1, pushupImg2, pushupImg3, pushupImg4, pushupImg5;
    let echecImg, victoryImg;
    let menuBgImg;          // fond du menu                 // variable globale
    const backSize = 60;   // taille du bouton ‚è™ visible partout


    function preload() {
      // Chargez vos 5 images pushup
      pushupImg1 = loadImage('pushup1.png');
      pushupImg2 = loadImage('pushup2.png');
      pushupImg3 = loadImage('pushup3.png');
      pushupImg4 = loadImage('pushup4.png');
      pushupImg5 = loadImage('pushup5.png');
      menuBgImg = loadImage('goodvibesmenu.png');

      // Charge les 2 nouvelles images
      echecImg = loadImage('echec.png');
      victoryImg = loadImage('victory.png');
    }

    /********************************************
     ** 2) SONS ET MUSIQUE (p5.sound)          **
     ********************************************/
    let retroOsc, retroEnv, pitchDropInterval;
    function setupRetroSound() {
      retroOsc = new p5.Oscillator('square');
      retroOsc.amp(0);
      retroOsc.start();
      retroEnv = new p5.Envelope();
      // ADSR court et percussif
      retroEnv.setADSR(0.01, 0.1, 0.2, 0.3);
      retroEnv.setRange(1, 0);
    }
    function playRetroSound() {
      let startFreq = 400; 
      retroOsc.freq(startFreq);
      retroEnv.play(retroOsc);
      pitchDropInterval = setInterval(() => {
        startFreq -= 20;
        if (startFreq <= 100) {
          clearInterval(pitchDropInterval);
        } else {
          retroOsc.freq(startFreq);
        }
      }, 20);
    }

    // Musique de fond (basse + m√©lodie)
    let bgBassOsc, bgBassEnv, bgMelodyOsc, bgMelodyEnv, bgMusicLoop;
    let bgBassPattern, bgMelodyPattern, bgMusicStep;
    function setupBackgroundMusic() {
      // Basse
      bgBassOsc = new p5.Oscillator('sine');
      bgBassOsc.start();
      bgBassOsc.amp(0);
      bgBassEnv = new p5.Envelope();
      bgBassEnv.setADSR(0.05, 0.1, 0.5, 0.2);
      bgBassEnv.setRange(0.4, 0);
      bgBassPattern = [
        130.82, 0, 130.82, 0, 146.83, 0, 130.82, 0,
        130.82, 0, 130.82, 0, 146.83, 0, 130.82, 0,
        130.82, 0, 130.82, 0, 146.83, 0, 130.82, 0,
        130.82, 0, 130.82, 0, 146.83, 0, 130.82, 0
      ];
      // M√©lodie
      bgMelodyOsc = new p5.Oscillator('triangle');
      bgMelodyOsc.start();
      bgMelodyOsc.amp(0);
      bgMelodyEnv = new p5.Envelope();
      bgMelodyEnv.setADSR(0.05, 0.1, 0.5, 0.2);
      bgMelodyEnv.setRange(0.3, 0);
      bgMelodyPattern = [
        261.63, 293.66, 329.63, 0, 392.00, 392.00, 329.63, 0,
        261.63, 261.63, 293.66, 0, 329.63, 392.00, 440.00, 0,
        392.00, 349.23, 329.63, 0, 293.66, 293.66, 261.63, 0,
        261.63, 293.66, 329.63, 392.00, 329.63, 293.66, 261.63, 0
      ];
      bgMusicStep = 0;
      let noteInterval = 0.3; // 0.3 s par note
      bgMusicLoop = new p5.SoundLoop(function(time) {
        let bassNote = bgBassPattern[bgMusicStep];
        if (bassNote > 0) {
          bgBassOsc.freq(bassNote, 0.05);
          bgBassEnv.play(bgBassOsc, time);
        }
        let melodyNote = bgMelodyPattern[bgMusicStep];
        if (melodyNote > 0) {
          bgMelodyOsc.freq(melodyNote, 0.05);
          bgMelodyEnv.play(bgMelodyOsc, time);
        }
        bgMusicStep = (bgMusicStep + 1) % bgBassPattern.length;
      }, noteInterval);
    }
    function startBackgroundMusic() {
      if (bgMusicLoop) bgMusicLoop.start();
    }
    function stopBackgroundMusic() {
      if (bgMusicLoop) bgMusicLoop.stop();
    }

    // Son de victoire
    let victoryOsc, victoryEnv;
    function setupVictorySound() {
      victoryOsc = new p5.Oscillator('sawtooth');
      victoryOsc.start();
      victoryOsc.amp(0);
      victoryEnv = new p5.Envelope();
      victoryEnv.setADSR(0.01, 0.15, 0.1, 0.2);
      victoryEnv.setRange(1, 0);
    }
    function playVictorySound() {
      if (!victoryOsc) setupVictorySound();
      let notes = [523.25, 659.25, 783.99];
      let delay = 0;
      notes.forEach(note => {
        setTimeout(() => {
          victoryOsc.freq(note, 0.05);
          victoryEnv.play(victoryOsc);
        }, delay * 1000);
        delay += 0.25;
      });
    }

    // Happy Ending
    let happyOsc, happyEnv;
    function setupHappyEndingSound() {
      happyOsc = new p5.Oscillator('triangle');
      happyOsc.start();
      happyOsc.amp(0);
      happyEnv = new p5.Envelope();
      happyEnv.setADSR(0.05, 0.15, 0.6, 0.3);
      happyEnv.setRange(0.5, 0);
    }
    function playHappyEndingMelody() {
      if (!happyOsc) setupHappyEndingSound();
      let melody = [523.25, 587.33, 659.25, 698.46, 783.99, 880.00, 987.77, 1046.50];
      let delay = 0;
      melody.forEach(note => {
        setTimeout(() => {
          happyOsc.freq(note, 0.05);
          happyEnv.play(happyOsc);
        }, delay * 1000);
        delay += 0.5;
      });
    }

  /********************************************
 ** 3) VARIABLES & √âTATS DU JEU (global)   **
 ********************************************/
let mode = "menu"; // menu principal
const MODE_RECORDS = "records"; // bouton Records    
// --- MENU & fl√®che retour ---
let menuButtons = [];    // tableau des 6 boutons
let backButton  = null;  // bouton ‚è™ pour revenir au menu
// ‚Äî‚Äî‚Äî Countdown 5¬†s avant le start ‚Äî‚Äî‚Äî
const countdownDuration = 5000;  // dur√©e du compte √† rebours en millisecondes
let countdownActive     = false; // true pendant le compte √† rebours
let countdownStartTime  = 0;     // timestamp de d√©but du compte √† rebours
let running = false;
let startTime = 0;
let elapsedTime = 0;
let gameStarted = false;
let showIntro = true;
let introStartTime = 0;
const uiMargin = 80;

let linePoints = [];
let currentX = 0;
let currentY;
let currentZone = 3; // zone dynamique

let speedX = 0.3;
let offsetX = 0;
let nextZoneTransitionTime = 0;
let transitionInProgress = false;
let zoneTransitionStartTime = 0;
const zoneTransitionDuration = 1500;
let oldY = 0;
let targetY = 0;
let targetZone = 3;
let oscillateMode = false;
let oscillationStartTime = 0;
const oscillationPeriod = 3000;

/*  Dur√©es progressives de chaque niveau¬†(ms)
    Somme¬†= 180¬†000¬†ms (180¬†s)  */
const levelDurations = [18000, 21000, 23000, 25000, 27000, 30000, 36000];

const strokeColors = ["#8A2BE2", "#4B0082", "#0000FF", "#008000", "#FFFF00", "#FFA500", "#FF0000"];
let currentColor = strokeColors[0];

/* Transition finale apr√®s 180¬†s */
const victoryTime = 180000;

const spiralDuration = 5000;
const flagBlinkCycleDuration = 500;
const flagDisplayDuration = 250;
const flagTargetBlink = 5;
let transitionStartTime = null;
let spiralStartTime = null;
let finalPointAtVictory = null;
let finalPopupBlinkCount = 0;
let lastPopupCycleTime = 0;
const popupCycleDuration = 500;
const popupDisplayDuration = 300;
const finalPopupTargetBlink = 8;
let finalPopupPermanent = false;
const popupW = 300;
const popupH = 100;
const popupRadius = 15;
let canvas;

// Suivi du niveau (popups)
let prevLevel = 1;
let levelPopupTimestamp = 0;

// Flags pour sons
let victorySoundPlayed = false;
let happyEndingPlayed = false;

// ----------------- NOUVEAUT√âS POUR √âCHEC & VICTORY ------------------
// √âchec
let echecActive = false;   // Indique si "√©chec" est affich√©
let echecX = 0, echecY = 0; // Position finale o√π on dessine echec.png

// On va dessiner victory.png en mode spiral
// (√Ä la place du rectangle blanc + "üí™üí™üí™")
// -------------------------------------------------------------------


    /********************************************
     ** 4) Fonctions pour D√âTECTER la zone     **
     ********************************************/
    function getZoneFromY(y) {
      for (let i = 1; i <= 5; i++) {
        let top = zoneTopY(i);
        let bottom = zoneBottomY(i);
        if (y >= top && y < bottom) {
          return i;
        }
      }
      return 5;
    }

    /********************************************
     ** 5) Afficher l'image pushup selon zone  **
     ********************************************/
    function drawPushupImageForZone(zoneIndex) {
      if (mode !== "playing" || !running) return;

      let chosenImg = null;
      if (zoneIndex === 1) chosenImg = pushupImg1;
      else if (zoneIndex === 2) chosenImg = pushupImg2;
      else if (zoneIndex === 3) chosenImg = pushupImg3;
      else if (zoneIndex === 4) chosenImg = pushupImg4;
      else if (zoneIndex === 5) chosenImg = pushupImg5;
      if (!chosenImg) return;

      let effectiveHeight = height - uiMargin;
      let zoneH = effectiveHeight / 5;
      let desiredH = zoneH * 0.75; 
      let ratio = desiredH / chosenImg.height;
      let displayW = chosenImg.width * ratio;
      let displayH = chosenImg.height * ratio;

      let xPos = (currentX - offsetX) + 30;
      let yPos = currentY;

      // Limiter en bas si zone 5
      let bottomLimit = height - displayH / 2;
      if (zoneIndex === 5 && yPos > bottomLimit) {
        yPos = bottomLimit;
      }

      imageMode(CENTER);
      image(chosenImg, xPos, yPos, displayW, displayH);
    }

    // ------------------ FONCTION POUR DESSINER echec.png -------------------
    function drawEchecImage() {
      if (!echecActive) return; // Pas d'√©chec en cours => on ne dessine rien

      // On veut la m√™me dimension 3/4 d'une zone
      let effectiveHeight = height - uiMargin;
      let zoneH = effectiveHeight / 5;
      let desiredH = zoneH * 0.75;
      let ratio = desiredH / echecImg.height;
      let displayW = echecImg.width * ratio;
      let displayH = echecImg.height * ratio;

      // On tient compte de offsetX
      let xPos = (echecX - offsetX) + 30;
      let yPos = echecY;

      // R√©initialiser les records
      let resetRecordsBtn;

      // On dessine l'image
      imageMode(CENTER);
      image(echecImg, xPos, yPos, displayW, displayH);
    }
    // -----------------------------------------------------------------------


/********************************************
 ** 6) SETUP & RESIZE (p5.js)              **
 ********************************************/

// Active ou d√©sactive temporairement les clics sur les boutons du menu
function toggleMenuButtons(enable) {
  menuButtons.forEach(b => {
    b.style('pointer-events', enable ? 'auto' : 'none');
  });
}

function setup() {
  canvas = createCanvas(windowWidth, windowHeight);
  canvas.position(0, 0);
  canvas.style('z-index', '-1');
  // ‚Üí Charger l‚Äôancien record (ou 0 si jamais d√©fini)
  bestTime = parseFloat(localStorage.getItem('pushupBestTime')) || 0;
  background(0);

  setupRetroSound();
  setupBackgroundMusic();

  introStartTime = millis();
  currentX = 0;
  currentZone = 3;
  currentY = zoneCenterY(currentZone);
  linePoints.push({ x: currentX, y: currentY });
  nextZoneTransitionTime = millis() + random(1000, 4000);

  /* ---- cache les √©l√©ments de jeu tant qu‚Äôon est dans le menu ---- */
  select('#startButton').hide();
  select('#stopButton').hide();
  select('#chrono').hide();
  select('#level').hide();

  /* ---- callbacks des boutons de jeu ---- */
  select('#startButton').mousePressed(startGame);
  select('#stopButton').mousePressed(stopGame);
  select('#restartButton').style('display', 'none');
  select('#restartButton').mousePressed(restartGame);

    validateBtn = createButton("Valider les perfs üíæ");
  validateBtn.id("validateButton");
  validateBtn.style('font-size', '20px');
  validateBtn.style('padding', '10px 20px');
  validateBtn.position(width/2 - 100, height/2 + 200);  // on repositionnera plus tard
  validateBtn.hide();
  validateBtn.mousePressed(onValidatePerf);

  resetRecordsBtn = createButton("R√©initialiser les records");
  resetRecordsBtn.id("resetRecordsButton");
  resetRecordsBtn.style('font-size', '18px');
  resetRecordsBtn.style('padding', '8px 16px');
  // on le cache par d√©faut
  resetRecordsBtn.hide();
  resetRecordsBtn.mousePressed(() => {
    bestTime = 0;
    localStorage.removeItem('pushupBestTime');
  });

  /* ========== Boutons du MENU ========== */
  const labels = ["Jouer", "Instructions", "Personnages",
                  "Records", "D√©fis et Troph√©es", "Quitter"];

  labels.forEach((txt, i) => {
    const labelHTML = (txt === "D√©fis et Troph√©es")
                      ? "D√©fis&nbsp;et<br>Troph√©es"
                      : txt;

    const btn = createButton(labelHTML);
    btn.position(width / 2 - 80, height / 2 - 120 + i * 60);
    btn.size(160, 40);
    btn.style('z-index', '15');
    btn.style('display', 'flex');
    btn.style('align-items', 'center');
    btn.style('justify-content', 'center');
    btn.style('text-align', 'center');
    btn.style('white-space', 'normal');
    btn.style('font-size', '18px');
    btn.style('line-height', '18px');
    btn.style('padding', '0');
    btn.mousePressed(() => menuClick(txt));
    menuButtons.push(btn);
  });

  /* cache les boutons pendant l‚Äôintro & d√©sactive leurs clics */
  menuButtons.forEach(b => b.hide());
  toggleMenuButtons(false);

  /* la suite : d√©sactive Instr., Perso., ‚Ä¶ sauf Jouer et Records */
  menuButtons.forEach((b, i) => {
    const txt = labels[i];
    if (txt !== "Jouer" && txt !== "Records") b.attribute('disabled', '');
  });

  function onValidatePerf() {
  // si la session courante bat le record stock√©, on met √† jour
  if (sessionTime > bestTime) {
    bestTime = sessionTime;
    localStorage.setItem('pushupBestTime', bestTime);
  }
  // message √©ph√©m√®re
  let msg = createDiv("Perfs enregistr√©es");
  msg.style('position','absolute');
  msg.style('top','50%');
  msg.style('left','50%');
  msg.style('transform','translate(-50%,-50%)');
  msg.style('padding','10px 20px');
  msg.style('background','white');
  msg.style('color','black');
  msg.style('font-size','18px');
  setTimeout(() => msg.remove(), 1000);
  }

  /* ===== fl√®che ‚è™ ===== */
  backButton = createButton("‚è™");
  backButton.position(windowWidth - backSize - 10,
                      windowHeight - backSize - 10);
  backButton.size(backSize, backSize);
  backButton.style('font-size', '36px');
  backButton.style('z-index', '15');
  backButton.style('background', 'transparent');
  backButton.style('border', 'none');
  backButton.style('outline', 'none');
  backButton.style('display', 'flex');
  backButton.style('align-items', 'center');
  backButton.style('justify-content', 'center');
  backButton.style('padding', '0');
  backButton.mousePressed(goToMenu);
  backButton.hide();           // visible hors menu
}   // <-- FIN de setup()
    

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);

  // recentre les boutons du menu
  menuButtons.forEach((btn, i) => {
    btn.position(width / 2 - 80, height / 2 - 120 + i * 60);
  });

  // repositionne la fl√®che ‚è™ dans le coin bas-droit
  if (backButton) {
    backButton.position(windowWidth - backSize - 10,
                        windowHeight - backSize - 10);
  }
}


    function menuClick(label) {
  if (label === "Jouer") {
    // cacher le menu, montrer Start/Stop et lancer le mode playing
    menuButtons.forEach(b => b.hide());
    toggleMenuButtons(false);
    select('#startButton').show();
    select('#stopButton').show();
    backButton.show();
    mode = "playing";
    showIntro = false;       // ne revisite pas l'introduction
  }
  else if (label === "Records") {             // <-- nouveau cas
    menuButtons.forEach(b => b.hide());         // cacher le menu
    backButton.show();                          // fl√®che visible
    select('#startButton').hide();              // rien d'autre
    select('#stopButton').hide();
    select('#chrono').hide();
    select('#level').hide();
    mode = MODE_RECORDS;                        // on passe en mode records
  }
      // d'autres boutons seront cod√©s plus tard
}

function goToMenu() {
  running = false;
  stopBackgroundMusic();
  backButton.hide();
  select('#startButton').hide();
  select('#stopButton').hide();
    // cache chrono et niveau de nouveau
  select('#chrono').hide();
  select('#level').hide();
  restartGame();             // r√©initialise le jeu
  menuButtons.forEach(b => b.show());
  mode = "menu";
  resetRecordsBtn.hide()
}

    /********************************************
     ** 7) BOUTONS : START, STOP, RESTART      **
     ********************************************/
   function startGame() {
  userStartAudio();  // d√©bloque l'audio sur mobile

  // 1er clic : on lance le compte √† rebours au lieu de d√©marrer direct
  if (!gameStarted) {
        // on affiche le chrono et le niveau d√®s le compte √† rebours
    select('#chrono').show();
    select('#level').show();
    
    countdownActive    = true;
    countdownStartTime = millis();
    gameStarted        = true;  // marque le d√©but (m√™me si on n'est pas encore running)
    return;
  }

  // clics suivants (apr√®s le countdown) : lancement normal du jeu
  if (!running && mode === "playing") {
    echecActive = false;
    running     = true;
    startTime   = millis();
    startBackgroundMusic();
    prevLevel   = 1;
    levelPopupTimestamp = millis();
    victorySoundPlayed  = false;
    happyEndingPlayed   = false;
  }
}

    function stopGame() {
      // Si on est en mode playing et qu'on est en train de courir
      if (running && mode === "playing") {
        // dur√©e de la session Go‚Üí√âchec
        sessionTime = millis() - startTime;
        running = false;
        stopBackgroundMusic();

        // Active l'image √©chec
        echecActive = true;
        // Position = dernier point de la ligne
        let lastPt = linePoints[linePoints.length - 1];
        echecX = lastPt.x;
        echecY = lastPt.y;
      }
    }
    function restartGame() {
      mode = "playing";
      running = false;
      startTime = 0;
      elapsedTime = 0;
      gameStarted = false;

      currentX = 0;
      currentY = zoneCenterY(3);
      linePoints = [];
      linePoints.push({ x: currentX, y: currentY });
      currentZone = 3;

      nextZoneTransitionTime = millis() + random(1000, 4000);
      finalPopupBlinkCount = 0;
      lastPopupCycleTime = 0;
      finalPopupPermanent = false;

      select('#restartButton').style('display', 'none');
      select('#restartButton').hide();
      validateBtn.hide();
      select('#chrono').html("Temps: 0.0 sec");
      select('#level').html("Niveau: <span style='color:white;'>1</span>");

      // On enl√®ve l'image √©chec si elle √©tait pr√©sente
      echecActive = false;

      stopBackgroundMusic();
      victorySoundPlayed = false;
      happyEndingPlayed = false;
    }

/********************************************
 ** 8) DRAW : la boucle de rendu p5.js     **
 ********************************************/
function draw() {

  /* ‚Äî 1. Intro blanche ‚Äî */
  if (showIntro) {
    background(255);
    textAlign(CENTER, CENTER);
    textSize(40);
    fill(0);
    text("Push Up Odyssey", width / 2, height / 2);

    textSize(16);                  // num√©ro de version
    fill(0, 0, 255);
    text("v3.40a", width / 2, height - 30);

    if (millis() - introStartTime >= 2000) showIntro = false;
    return;
  }

  /* ‚Äî 2. Menu principal ‚Äî */
  if (mode === "menu") {
    drawMenu();
    return;
  }

  /* ‚Äî 3. Page Records ‚Äî */
  if (mode === MODE_RECORDS) {
    drawRecords();
    return;
  }

  /* ‚Äî 4. Compte √† rebours ‚Äî */
  if (countdownActive) {
    background(0);
    textAlign(CENTER, CENTER);
    textSize(80);
    fill(255);

    let elapsed     = millis() - countdownStartTime;
    let secondsLeft = 5 - floor(elapsed / 1000);
    text(secondsLeft > 0 ? secondsLeft : "GO!", width / 2, height / 2);

    if (elapsed >= countdownDuration) {
      countdownActive = false;
      running         = true;
      startTime       = millis();
      startBackgroundMusic();
    }
    return;
  }

  /* ‚Äî 5. Modes de jeu ‚Äî */
  if (mode === "playing") {
    playMode();
    drawZoneBoundaries();
    drawZoneLabels();
    drawLevelPopup();
    drawPushupImageForZone(currentZone);
    drawEchecImage();
  }
  else if (mode === "transition") {
    transitionMode();
  }
  else if (mode === "spiral") {
    spiralMode();
  }
}  // ‚Üê fin de draw()


/* ----------------------------------------------------------
   Affichage du menu principal (fond + boutons)
---------------------------------------------------------- */
function drawMenu() {
  imageMode(CORNER);
  image(menuBgImg, 0, 0, width, height);   // fond plein √©cran
  toggleMenuButtons(true);                 // r√©-active les clics
  menuButtons.forEach(b => b.show());      // montre les 6 boutons
}

/* ----------------------------------------------------------
   Page ¬´ Records ¬ª ‚Äì fond noir + 6 lignes orange r√©tro
---------------------------------------------------------- */
function drawRecords() {
  background(0);
  textAlign(LEFT, TOP);
  textStyle(BOLD);
  textSize(15);
  fill('#FF7F00');

  // conversion en secondes
  let bestSec = (bestTime / 1000).toFixed(1);

  const marginX = 40;
  const lineH   = 40;
  const totalLines = 6;
  const startY  = (height - totalLines * lineH) / 2 + lineH/2;

  // 1√®re ligne : record dynamique
  text(`Plus longue s√©rie avant √©chec : ${bestSec} s`,
       marginX, startY + 0 * lineH);

  // autres libell√©s
  const otherLines = [
    "Odyss√©e la plus rapide :",
    "Record d'Odyss√©es encha√Æn√©es :",
    "Personnage pr√©f√©r√© :",
    "Nombre d'√©checs moyen par Odyss√©e :",
    "R√©gularit√© :"
  ];
  for (let i = 0; i < otherLines.length; i++) {
    text(otherLines[i],
         marginX, startY + (i+1) * lineH);
  }

  // on place et on montre le bouton de reset tout en bas, centr√©
  resetRecordsBtn
    .position(width/2 - resetRecordsBtn.size().width/2,
              height - 80)
    .show();
}


/********************************************
 ** 9) Jeu : playMode, transition, spiral  **
 ********************************************/
function playMode() {
    if (backButton) backButton.show();
  let totalTime = elapsedTime;
  if (running) totalTime += millis() - startTime;

  /* ------ Calcul progressif du niveau ------ */
  let level = 7;              // par d√©faut (temps ‚â• somme)
  let cumulative = 0;
  for (let i = 0; i < levelDurations.length; i++) {
    cumulative += levelDurations[i];
    if (totalTime < cumulative) {
      level = i + 1;          // niveaux¬†1¬†‚Üí¬†7
      break;
    }
  }
  currentColor = strokeColors[level - 1];
  /* ----------------------------------------- */

  /* ------ Dur√©e d‚Äôattente avant changement de zone (d√©cro√Æt avec le niveau) ------ */
  let delayMin = map(level, 1, 7, 1000,  50);   // Niveau¬†1¬†‚Üí¬†1¬†000¬†ms, niveau¬†7¬†‚Üí¬†50¬†ms
  let delayMax = map(level, 1, 7, 4000, 200);   // Niveau¬†1¬†‚Üí¬†4¬†000¬†ms, niveau¬†7¬†‚Üí¬†200¬†ms
  /* -------------------------------------------------------------------------------- */

  let seconds = (totalTime / 1000).toFixed(1);
  select('#chrono').html("Temps: " + seconds + " sec");
  select('#level').html("Niveau: <span style='font-weight:bold; background-color:white; padding:2px; color:" +
                          currentColor + ";'>" + level + "</span>");

  // Passage en mode transition (victoire) apr√®s 180¬†s
  if (totalTime >= victoryTime) {
    finalPointAtVictory = linePoints[linePoints.length - 1];
    mode = "transition";
    transitionStartTime = millis();
    running = false;
    stopBackgroundMusic();
  } else {
    background(0);
    if (running) {
      currentX += speedX;

      if (!transitionInProgress && millis() >= nextZoneTransitionTime) {
        nextZoneTransitionTime = 0;
        let p = random(1);
        let newZone = currentZone;

        if (p < 0.4) {
          newZone = currentZone;
        } else if (p < 0.6) {
          let candidates = [];
          if (currentZone > 1) candidates.push(currentZone - 1);
          if (currentZone < 5) candidates.push(currentZone + 1);
          if (candidates.length > 0) newZone = random(candidates);
        } else if (p < 0.8) {
          let candidates = [];
          if (currentZone - 2 >= 1) candidates.push(currentZone - 2);
          if (currentZone + 2 <= 5) candidates.push(currentZone + 2);
          if (candidates.length > 0) newZone = random(candidates);
        } else {
          if (currentZone === 1) newZone = 5;
          else if (currentZone === 5) newZone = 1;
          else if (currentZone === 2) newZone = 5;
          else if (currentZone === 4) newZone = 1;
          else if (currentZone === 3) newZone = random([1, 5]);
        }

        transitionInProgress = true;
        zoneTransitionStartTime = millis();
        oldY = currentY;
        targetY = zoneCenterY(newZone);
        targetZone = newZone;
      }

      if (transitionInProgress) {
        let progress = (millis() - zoneTransitionStartTime) / zoneTransitionDuration;
        progress = constrain(progress, 0, 1);
        let newY = lerp(oldY, targetY, progress);

        let dynamicZone = getZoneFromY(newY);
        currentZone = dynamicZone;

        if (!oscillateMode) {
          currentY = newY;
        } else {
          let baseY = newY;
          let amplitude = 10;
          let oscillVal = amplitude * sin(TWO_PI * (millis() - oscillationStartTime) / oscillationPeriod);
          currentY = baseY + oscillVal;
        }

        if (progress >= 1) {
          transitionInProgress = false;
          /* ------------ d√©lai suivant d√©pend du niveau ------------ */
          nextZoneTransitionTime = millis() + random(delayMin, delayMax);
          /* -------------------------------------------------------- */
          oscillateMode = (random(1) < 0.5);        // on garde encore des oscillations
          if (oscillateMode) oscillationStartTime = millis();
        }
      } else {
        if (oscillateMode) {
          let baseY = zoneCenterY(currentZone);
          let amplitude = 10;
          let oscillVal = amplitude * sin(TWO_PI * (millis() - oscillationStartTime) / oscillationPeriod);
          currentY = baseY + oscillVal;
        } else {
          currentY = zoneCenterY(currentZone);
        }
      }

      linePoints.push({ x: currentX, y: currentY });
    }

    offsetX = currentX > width / 3 ? currentX - width / 3 : 0;
    strokeWeight(4);
    stroke(currentColor);
    noFill();
    beginShape();
    for (let pt of linePoints) {
      vertex(pt.x - offsetX, pt.y);
    }
    endShape();
  }
}

    function transitionMode() {
        if (backButton) backButton.show();
      strokeWeight(4);
      stroke(currentColor);
      noFill();
      beginShape();
      for (let pt of linePoints) {
        vertex(pt.x - offsetX, pt.y);
      }
      endShape();
      
  /* ----------- Image push‚Äëup au bout de la ligne ----------- */
  drawPushupImageForZone(currentZone);
      
      let elapsed = millis() - transitionStartTime;
      let blinkCycle = floor(elapsed / flagBlinkCycleDuration);
      if (blinkCycle < flagTargetBlink) {
        if ((elapsed % flagBlinkCycleDuration) < flagDisplayDuration) {
          textAlign(CENTER, CENTER);
          textSize(60);
          fill(255);
          text("üèÅ", finalPointAtVictory.x - offsetX +90, finalPointAtVictory.y);
        }
      } else {
        // On affiche le drapeau en permanence
        if (!victorySoundPlayed) {
          playVictorySound();
          victorySoundPlayed = true;
        }
        textAlign(CENTER, CENTER);
        textSize(40);
        fill(255);
        text("üèÅ", finalPointAtVictory.x - offsetX +90, finalPointAtVictory.y);

        // Passage en mode "spiral"
        mode = "spiral";
        spiralStartTime = millis();
        finalPopupBlinkCount = 0;
        lastPopupCycleTime = millis();
        finalPopupPermanent = false;
      }
      select('#chrono').html("NIVEAU 8 üí™üí™üí™");
      select('#level').html("");
    }

    function spiralMode() {
        if (backButton) backButton.show();
      background(0);
      let cx = width / 2, cy = height / 2;
      let dt = millis() - spiralStartTime;
      let p = constrain(dt / spiralDuration, 0, 1);
      let numTurns = 6;
      let thetaMax = numTurns * TWO_PI;
      let currentTheta = p * thetaMax;
      let rMax = dist(0, 0, width, height) / 2;
      let k = rMax / thetaMax;

      colorMode(HSB, 360, 100, 100);
      strokeWeight(4);
      noFill();
      let step = 0.05;
      let prevX = cx, prevY = cy;
      for (let theta = 0; theta < currentTheta; theta += step) {
        let r = k * theta;
        let x = cx + r * cos(theta);
        let y = cy + r * sin(theta);
        let turnIndex = floor(theta / TWO_PI);
        let hueVal = map(turnIndex, 0, numTurns, 0, 360);
        stroke(hueVal, 100, 100);
        line(prevX, prevY, x, y);
        prevX = x;
        prevY = y;
      }
      colorMode(RGB);

      if (!happyEndingPlayed) {
        playHappyEndingMelody();
        happyEndingPlayed = true;
      }
      drawFinalPopup(); 
    }

    /********************************************
     ** 9.1) Le POPUP de fin (dessin)          **
     ********************************************/
    function drawFinalPopup() {
      // On garde le cycle de clignotement, mais on ne dessine plus le rectangle blanc ni "üí™üí™üí™"
      // √Ä la place, on dessine victory.png, coll√© en bas, centr√© horizontalement.
      let cycleDuration = popupCycleDuration;
      let displayDuration = popupDisplayDuration;

      if (!finalPopupPermanent) {
        if (millis() - lastPopupCycleTime >= cycleDuration) {
          lastPopupCycleTime = millis();
          finalPopupBlinkCount++;
        }
        if (millis() - lastPopupCycleTime < displayDuration) {
          drawVictoryImage();
        }
        if (finalPopupBlinkCount >= finalPopupTargetBlink) {
          finalPopupPermanent = true;
          drawVictoryImage();
          select('#restartButton').style('display', 'block');
          select('#restartButton').style('left', (width / 2 - 75) + 'px');
          select('#restartButton').style('top', (height / 2 + 150) + 'px');
          // montrer le bouton Valide
          validateBtn.position(width/2 - 100, height/2 + 220).show();
        }
      } else {
        drawVictoryImage();
      }
    }

    function drawVictoryImage() {
      // On veut un grand ratio (ex: 80% de la hauteur)
      let desiredH = height * 0.8;
      let ratio = desiredH / victoryImg.height;
      let displayW = victoryImg.width * ratio;
      let displayH = victoryImg.height * ratio;

      // Bas coll√© √† l'√©cran => y = height - displayH/2
      let xPos = width / 2;
      let yPos = height - displayH / 2;

      imageMode(CENTER);
      image(victoryImg, xPos, yPos, displayW, displayH);
    }

/********************************************
 ** 9.2) drawLevelPopup(): gros chiffre    **
 ********************************************/
function drawLevelPopup() {
  if (mode !== "playing" || !gameStarted) return;

  let totalTime = elapsedTime;
  if (running) totalTime += millis() - startTime;

  /* ------ Calcul progressif du niveau ------ */
  let level = 7;
  let cumulative = 0;
  for (let i = 0; i < levelDurations.length; i++) {
    cumulative += levelDurations[i];
    if (totalTime < cumulative) {
      level = i + 1;
      break;
    }
  }
  /* ----------------------------------------- */

  if (level !== prevLevel) {
    playRetroSound();
    levelPopupTimestamp = millis();
    prevLevel = level;
  }
  if (millis() - levelPopupTimestamp < 1000) {
    push();
    textAlign(CENTER, CENTER);
    textSize(100);

    let displayText = level.toString();
    let txtW = textWidth(displayText);
    let padding = 20;
    let rectW = txtW + 2 * padding;
    let rectH = 100;

    let rectX = width - 20 - rectW / 2;
    let rectY = height / 2;

    rectMode(CENTER);
    noStroke();
    fill(255);
    rect(rectX, rectY, rectW, rectH, 15);

    fill(currentColor);
    text(displayText, rectX, rectY);
    pop();
  }
}

/********************************************
 ** 10) Fonctions utilitaires (zones, etc.)**
 ********************************************/
function zoneCenterY(z) {
  const effectiveHeight = height - uiMargin;
  const zoneHeight      = effectiveHeight / 5;
  return uiMargin + (z - 0.5) * zoneHeight;
}
function zoneTopY(z) {
  const effectiveHeight = height - uiMargin;
  return uiMargin + (z - 1) * (effectiveHeight / 5);
}
function zoneBottomY(z) {
  const effectiveHeight = height - uiMargin;
  return uiMargin + z * (effectiveHeight / 5);
}

function drawZoneBoundaries() {
  stroke(150);
  strokeWeight(1);
  const effectiveHeight = height - uiMargin;
  const zoneHeight      = effectiveHeight / 5;
  for (let i = 0; i <= 5; i++) {
    const y = uiMargin + i * zoneHeight;
    drawDashedLine(0, y, width, y, 10, 5);
  }
}
function drawDashedLine(x1, y1, x2, y2, dash, gap) {
  const d = dist(x1, y1, x2, y2);
  const n = floor(d / (dash + gap));
  const v = createVector(x2 - x1, y2 - y1).div(d);
  for (let i = 0; i < n; i++) {
    const sx = x1 + v.x * i * (dash + gap);
    const sy = y1 + v.y * i * (dash + gap);
    const ex = sx + v.x * dash;
    const ey = sy + v.y * dash;
    line(sx, sy, ex, ey);
  }
}
function drawZoneLabels() {
  push();
  textAlign(LEFT, CENTER);
  textSize(12);
  fill(150, 150);
  text("tout en haut", 20, uiMargin + 8);
  text("milieu",       20, zoneCenterY(3) - 8);
  text("tout en bas",  20, height - 8);
  pop();
}

/*********************************************
 ** 11) R√©enregistrement du Service Worker  **
 *********************************************/
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker
             .register('sw.js')
             .then(reg => console.log('ServiceWorker enregistr√© :', reg.scope))
             .catch(err => console.log('ServiceWorker √©chec :', err));
  });
}

/* ====== LOGGER VISUEL (√† placer juste avant </body>) ====== */
</script>

<div id="logger"
     style="position:fixed;bottom:0;left:0;right:0;
            max-height:40%;overflow:auto;
            background:#300;color:#ff8080;
            font-family:monospace;font-size:12px;
            padding:4px;z-index:9999;display:none;"></div>

<script>
// 1) Erreurs JS non captur√©es
window.onerror = (msg, src, line) => {
  const log = document.getElementById('logger');
  if (!log) return;
  log.style.display = 'block';
  log.innerText += `\n${msg}  (${src}:${line})`;
};

// 2) Redirige console.log / warn / error
/*['log','warn','error'].forEach(fn => {
  const o = console[fn];
  console[fn] = (...a) => {
    o.apply(console, a);
    const log = document.getElementById('logger');
    if (!log) return;
    log.style.display = 'block';
    log.innerText += `\n[${fn}] ${a.join(' ')}`;
  };
});*/
</script>
</body>
</html>

